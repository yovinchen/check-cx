/**
 * 数据库 Schema 自动初始化
 *
 * 仅在 PostgreSQL 模式下运行，自动创建所需的表、索引、视图和函数
 */

import postgres from "postgres";

const DB_SCHEMA =
  process.env.DATABASE_SCHEMA ||
  (process.env.NODE_ENV === "development" ? "dev" : "public");

/**
 * 初始化数据库 Schema
 *
 * @param databaseUrl PostgreSQL 连接字符串
 */
export async function initPostgresSchema(databaseUrl: string): Promise<void> {
  const sql = postgres(databaseUrl, {
    max: 1,
    idle_timeout: 10,
    connect_timeout: 10,
  });

  try {
    console.log(`[check-cx] 检查数据库 Schema (${DB_SCHEMA})...`);

    // 检查 check_configs 表是否存在
    const [{ exists }] = await sql`
      SELECT EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_schema = ${DB_SCHEMA}
        AND table_name = 'check_configs'
      )
    `;

    if (exists) {
      console.log("[check-cx] 数据库表已存在，跳过初始化");
      return;
    }

    console.log("[check-cx] 首次运行，初始化数据库表...");

    // 创建 Schema（如果不是 public）
    if (DB_SCHEMA !== "public") {
      await sql.unsafe(`CREATE SCHEMA IF NOT EXISTS ${DB_SCHEMA}`);
    }

    // 创建枚举类型
    await sql.unsafe(`
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'provider_type') THEN
          CREATE TYPE ${DB_SCHEMA}.provider_type AS ENUM ('openai', 'gemini', 'anthropic');
        END IF;
      END
      $$
    `);

    // 创建配置表
    await sql.unsafe(`
      CREATE TABLE IF NOT EXISTS ${DB_SCHEMA}.check_configs (
        id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        name            text NOT NULL,
        type            ${DB_SCHEMA}.provider_type NOT NULL,
        model           text NOT NULL,
        endpoint        text NOT NULL,
        api_key         text NOT NULL,
        enabled         boolean DEFAULT true,
        is_maintenance  boolean DEFAULT false,
        request_header  jsonb,
        group_name      text,
        metadata        jsonb,
        created_at      timestamptz DEFAULT now(),
        updated_at      timestamptz DEFAULT now()
      )
    `);

    // 创建历史记录表
    await sql.unsafe(`
      CREATE TABLE IF NOT EXISTS ${DB_SCHEMA}.check_history (
        id              bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        config_id       uuid NOT NULL REFERENCES ${DB_SCHEMA}.check_configs(id) ON DELETE CASCADE,
        status          text NOT NULL,
        latency_ms      integer,
        ping_latency_ms double precision,
        checked_at      timestamptz NOT NULL,
        message         text,
        created_at      timestamptz DEFAULT now(),
        CONSTRAINT check_status_valid CHECK (status IN ('operational', 'degraded', 'failed', 'validation_failed', 'error')),
        CONSTRAINT check_latency_positive CHECK (latency_ms IS NULL OR latency_ms >= 0)
      )
    `);

    // 创建分组信息表
    await sql.unsafe(`
      CREATE TABLE IF NOT EXISTS ${DB_SCHEMA}.group_info (
        id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        group_name  text NOT NULL UNIQUE,
        website_url text,
        tags        text NOT NULL DEFAULT '',
        created_at  timestamptz DEFAULT now(),
        updated_at  timestamptz DEFAULT now()
      )
    `);

    // 创建系统通知表
    await sql.unsafe(`
      CREATE TABLE IF NOT EXISTS ${DB_SCHEMA}.system_notifications (
        id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        message     text NOT NULL,
        is_active   boolean DEFAULT true,
        level       text DEFAULT 'info',
        created_at  timestamptz DEFAULT now()
      )
    `);

    // 创建轮询租约表
    await sql.unsafe(`
      CREATE TABLE IF NOT EXISTS ${DB_SCHEMA}.check_poller_leases (
        lease_key        text PRIMARY KEY,
        leader_id        text,
        lease_expires_at timestamptz NOT NULL,
        updated_at       timestamptz NOT NULL DEFAULT now()
      )
    `);

    // 插入默认租约行
    await sql.unsafe(`
      INSERT INTO ${DB_SCHEMA}.check_poller_leases (lease_key, leader_id, lease_expires_at)
      VALUES ('poller', NULL, to_timestamp(0))
      ON CONFLICT (lease_key) DO NOTHING
    `);

    // 创建索引
    await sql.unsafe(`
      CREATE INDEX IF NOT EXISTS idx_check_history_config_id
        ON ${DB_SCHEMA}.check_history (config_id)
    `);
    await sql.unsafe(`
      CREATE INDEX IF NOT EXISTS idx_check_history_checked_at
        ON ${DB_SCHEMA}.check_history (checked_at DESC)
    `);
    await sql.unsafe(`
      CREATE INDEX IF NOT EXISTS idx_history_config_checked
        ON ${DB_SCHEMA}.check_history (config_id, checked_at DESC)
    `);

    // 创建可用性统计视图
    await sql.unsafe(`
      CREATE OR REPLACE VIEW ${DB_SCHEMA}.availability_stats AS
      SELECT
        config_id,
        '7d'::text AS period,
        COUNT(*) AS total_checks,
        COUNT(*) FILTER (WHERE status = 'operational') AS operational_count,
        ROUND(100.0 * COUNT(*) FILTER (WHERE status = 'operational') / NULLIF(COUNT(*), 0), 2) AS availability_pct
      FROM ${DB_SCHEMA}.check_history
      WHERE checked_at > NOW() - INTERVAL '7 days'
      GROUP BY config_id
      UNION ALL
      SELECT
        config_id,
        '15d'::text AS period,
        COUNT(*) AS total_checks,
        COUNT(*) FILTER (WHERE status = 'operational') AS operational_count,
        ROUND(100.0 * COUNT(*) FILTER (WHERE status = 'operational') / NULLIF(COUNT(*), 0), 2) AS availability_pct
      FROM ${DB_SCHEMA}.check_history
      WHERE checked_at > NOW() - INTERVAL '15 days'
      GROUP BY config_id
      UNION ALL
      SELECT
        config_id,
        '30d'::text AS period,
        COUNT(*) AS total_checks,
        COUNT(*) FILTER (WHERE status = 'operational') AS operational_count,
        ROUND(100.0 * COUNT(*) FILTER (WHERE status = 'operational') / NULLIF(COUNT(*), 0), 2) AS availability_pct
      FROM ${DB_SCHEMA}.check_history
      WHERE checked_at > NOW() - INTERVAL '30 days'
      GROUP BY config_id
    `);

    // 创建 updated_at 触发器函数
    await sql.unsafe(`
      CREATE OR REPLACE FUNCTION ${DB_SCHEMA}.update_updated_at_column()
      RETURNS trigger
      LANGUAGE plpgsql
      AS $$
      BEGIN
        NEW.updated_at = now();
        RETURN NEW;
      END;
      $$
    `);

    // 创建触发器
    await sql.unsafe(`
      DROP TRIGGER IF EXISTS update_check_configs_updated_at ON ${DB_SCHEMA}.check_configs;
      CREATE TRIGGER update_check_configs_updated_at
        BEFORE UPDATE ON ${DB_SCHEMA}.check_configs
        FOR EACH ROW
        EXECUTE FUNCTION ${DB_SCHEMA}.update_updated_at_column()
    `);

    await sql.unsafe(`
      DROP TRIGGER IF EXISTS update_group_info_updated_at ON ${DB_SCHEMA}.group_info;
      CREATE TRIGGER update_group_info_updated_at
        BEFORE UPDATE ON ${DB_SCHEMA}.group_info
        FOR EACH ROW
        EXECUTE FUNCTION ${DB_SCHEMA}.update_updated_at_column()
    `);

    // 创建获取历史记录函数
    await sql.unsafe(`
      CREATE OR REPLACE FUNCTION ${DB_SCHEMA}.get_recent_check_history(
        limit_per_config integer DEFAULT 60,
        target_config_ids uuid[] DEFAULT NULL
      )
      RETURNS TABLE (
        config_id       uuid,
        status          text,
        latency_ms      integer,
        ping_latency_ms integer,
        checked_at      timestamptz,
        message         text,
        name            text,
        type            text,
        model           text,
        endpoint        text,
        group_name      text
      )
      LANGUAGE sql
      STABLE
      AS $func$
        WITH ranked AS (
          SELECT
            h.id AS history_id,
            h.config_id,
            h.status,
            h.latency_ms,
            h.ping_latency_ms,
            h.checked_at,
            h.message,
            row_number() OVER (PARTITION BY h.config_id ORDER BY h.checked_at DESC) AS rn
          FROM ${DB_SCHEMA}.check_history h
          WHERE target_config_ids IS NULL OR h.config_id = ANY(target_config_ids)
        )
        SELECT
          r.config_id,
          r.status,
          r.latency_ms,
          r.ping_latency_ms::integer,
          r.checked_at,
          r.message,
          c.name,
          c.type::text,
          c.model,
          c.endpoint,
          c.group_name
        FROM ranked r
        JOIN ${DB_SCHEMA}.check_configs c ON c.id = r.config_id
        WHERE r.rn <= limit_per_config
        ORDER BY c.name ASC, r.checked_at DESC;
      $func$
    `);

    // 创建清理历史记录函数
    await sql.unsafe(`
      DROP FUNCTION IF EXISTS ${DB_SCHEMA}.prune_check_history(integer);
      CREATE OR REPLACE FUNCTION ${DB_SCHEMA}.prune_check_history(
        retention_days integer DEFAULT NULL,
        limit_per_config integer DEFAULT NULL
      )
      RETURNS integer
      LANGUAGE plpgsql
      VOLATILE
      AS $func$
      DECLARE
        effective_days integer;
        deleted_count integer;
      BEGIN
        effective_days := LEAST(365, GREATEST(7, COALESCE(retention_days, limit_per_config, 30)));
        DELETE FROM ${DB_SCHEMA}.check_history
        WHERE checked_at < NOW() - (effective_days || ' days')::interval;
        GET DIAGNOSTICS deleted_count = ROW_COUNT;
        RETURN deleted_count;
      END;
      $func$
    `);

    console.log("[check-cx] 数据库初始化完成");
  } finally {
    await sql.end();
  }
}